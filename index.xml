<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>lobocode</title>
    <link>https://lobocode.github.io/</link>
    <description>Recent content on lobocode</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Vitor Lobo</copyright>
    <lastBuildDate>Tue, 21 Mar 2023 23:18:18 -0300</lastBuildDate><atom:link href="https://lobocode.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Prometheus</title>
      <link>https://lobocode.github.io/2023/03/21/prometheus/</link>
      <pubDate>Tue, 21 Mar 2023 23:18:18 -0300</pubDate>
      
      <guid>https://lobocode.github.io/2023/03/21/prometheus/</guid>
      <description>Introdução Instalação Promtool Instrumentação Alertmanager PushGateway Federação Under the Hood Introdução Prometheus O Prometheus é uma ferramenta de monitoramento de sistemas e aplicativos open-source. Foi desenvolvida com o objetivo de fornecer uma forma eficiente de coletar, armazenar e analisar métricas de desempenho de sistemas distribuídos. Ele foi projetado para ser escalável, fácil de usar e altamente personalizável. Possui sua própria linguagem de consulta, chamada PromQL, que permite aos usuários criar consultas complexas para analisar os dados de métricas.</description>
    </item>
    
    <item>
      <title>PromQL</title>
      <link>https://lobocode.github.io/2023/03/19/promql/</link>
      <pubDate>Sun, 19 Mar 2023 17:31:45 -0300</pubDate>
      
      <guid>https://lobocode.github.io/2023/03/19/promql/</guid>
      <description>Introdução Funções Agregadores e Operadores PromQL na prática Erros comuns Introdução PromQL, a linguagem de consulta de métricas do Prometheus, é uma ferramenta poderosa baseada em expressões regulares que permite aos usuários realizar consultas e configurar alertas sobre dados coletados. Seu principal objetivo é possibilitar a análise e monitoramento de métricas, como requisições HTTP por segundo ou a média de utilização de CPU por servidor, por meio de expressões que definem cálculos específicos.</description>
    </item>
    
    <item>
      <title>Java#Core - Collections</title>
      <link>https://lobocode.github.io/2022/12/05/collections/</link>
      <pubDate>Mon, 05 Dec 2022 17:31:45 -0300</pubDate>
      
      <guid>https://lobocode.github.io/2022/12/05/collections/</guid>
      <description>Streams foram adicionadas no Java 8 complicando substancialmente a tarefa de escolher o tipo de retorno mais adequado para um método que retornasse uma sequência. Afinal, agora podemos usar as streams para retornar uma sequência de elementos. No entanto, escrever um bom código exige uma combinação sensata de streams e iterações. Outro ponto é que utilizar excessivamente as streams faz com que os programas fiquem difíceis de se ler e de fazer manutenção.</description>
    </item>
    
    <item>
      <title>Java#Core - Read and Write</title>
      <link>https://lobocode.github.io/2022/12/08/javaio/</link>
      <pubDate>Thu, 08 Dec 2022 17:31:45 -0300</pubDate>
      
      <guid>https://lobocode.github.io/2022/12/08/javaio/</guid>
      <description>Dados armazenados em variáveis e arrays são temporários eles são perdidos quando programa termina. Para retenção persistente de longo prazo podemos usar o registro destes dados em arquivos. Felizmente, várias linguagens orientadas a objetos (incluindo Java) fornecem maneiras de gravá-los e lê-los de arquivos (conhecidas como serialização e desserialização de objetos). Para ilustrar isso, recriamos alguns de nossos programas de acesso sequencial que utilizaram arquivos de texto, dessa vez armazenando e recuperando objetos de arquivos binários.</description>
    </item>
    
    <item>
      <title>Java#Core - java.lang.OutOfMemoryError</title>
      <link>https://lobocode.github.io/2022/12/09/outofmemory/</link>
      <pubDate>Fri, 09 Dec 2022 05:31:45 -0300</pubDate>
      
      <guid>https://lobocode.github.io/2022/12/09/outofmemory/</guid>
      <description>Criar e manter estruturas de dados dinâmicos requer alocação dinâmica em memória. Isto é, permissão para que um programa obtenha mais espaço em memória e em tempo de execução para armazenar novos nodes e, ao mesmo tempo, liberar espaço não mais necessário. Lembre-se de que o Java não exige que você libere explicitamente a memória alocada dinamicamente. Em vez disso, ele realiza a coleta de lixo automática de objetos que não são mais referenciados em um programa.</description>
    </item>
    
    <item>
      <title>Ops - OpenShift</title>
      <link>https://lobocode.github.io/2019/06/08/openshift/</link>
      <pubDate>Sat, 08 Jun 2019 19:47:57 -0300</pubDate>
      
      <guid>https://lobocode.github.io/2019/06/08/openshift/</guid>
      <description>Este material foi elaborado com o propósito de compreender melhor o funcionamento do OpenShift, e de plataformas agregadas. Se houver por minha parte alguma informação errada, por favor, entre em contato ou me mande um pull request em meu perfil no github. As referências usadas para o estudo além da experiência prática, estarão no rodapé da página. Artigo em constante atualização e revisão.
CAPÍTULO 1 - O CONCEITO Breve introdução Plataforma em contêineres Casos de Uso Escalando Aplicações CAPÍTULO 2 - PREPARANDO O AMBIENTE Preparando para instalar o OpenShift Configurando o NetworkManager Instalando ferramentas no servidor master Configurando o conteiner storage Configurando o SElinux em seus nodes Instalando o OpenShift Executando o Playbook CAPÍTULO 3 - TEST DRIVE Criando Projetos Implementando nosso primeiro aplicativo Trabalhando diretamente com docker CAPÍTULO 4 - APROFUNDANDO Compreendendo o processo Um pouco sobre kubernetes Um pouco sobre Docker Fluxo de trabalho automatizado O namespace MOUNT O namespace UTS O namespace PID BREVE INTRODUCAO Imagine o seguinte cenário:</description>
    </item>
    
    <item>
      <title>Ops - Samba 4</title>
      <link>https://lobocode.github.io/2023/01/01/samba4/</link>
      <pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://lobocode.github.io/2023/01/01/samba4/</guid>
      <description>Esta é uma documentação não oficial do Samba 4 que fora elaborada através de um estudo pessoal e experiências práticas que tenho tido com o Samba em ambiente de produção. Se houver por minha parte alguma informação errada, por favor, entre em contato para que eu possa corrigir através do meu e-mail (lobocode@gmail.com), ou me mande um pull request no github. As referências usadas para o estudo além da experiência prática, estarão no rodapé da página.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://lobocode.github.io/page/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://lobocode.github.io/page/about/</guid>
      <description>Olá, sejam bem-vind(x)s ao meu blog. Fala galera! Me chamo Vitor Lobo mais conhecido como (lobocode) na comunidade e sou Software Engineer, escritor, gamer e pesquisador independente. Já trabalho com tecnologia há mais de 10 anos e adoro tudo o que envolve arte e cultura, como literatura, cinema, música, quadrinhos, mangás, animes e até uma boa praia! Adoro andar de bike e curtir o tempo livre com minha companheira e nossos gatinhos.</description>
    </item>
    
    <item>
      <title>Contact</title>
      <link>https://lobocode.github.io/page/contact/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://lobocode.github.io/page/contact/</guid>
      <description> E-mail: lobocode@gmail.com Linkedin: https://linkedin.com/in/vitor-lobo/ Mastodon: https://bolha.us/@lobocode </description>
    </item>
    
  </channel>
</rss>
